
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Common Prefix — The Landscape of Front-running Prevention</title>
		<meta name="description" content="An exploration of the strategies and trade-offs in defending decentralized finance users against front-running attacks." />

		<meta property="og:title" content="Common Prefix — The Landscape of Front-running Prevention">
		<meta property="og:description" content="An exploration of the strategies and trade-offs in defending decentralized finance users against front-running attacks.">
		<meta property="og:url" content="https://commonprefix.com/">
		<meta property="og:image" content="https://commonprefix.com/static/meta.png">

		<meta name="twitter:title" content="Common Prefix — The Landscape of Front-running Prevention">
		<meta name="twitter:description" content="An exploration of the strategies and trade-offs in defending decentralized finance users against front-running attacks.">
		<meta property="twitter:url" content="https://commonprefix.com/">
		<meta name="twitter:image" content="https://commonprefix.com/static/meta.png">
		<meta name="twitter:card" content="summary_large_image">
		<meta property="twitter:domain" content="commonprefix.com">

		<link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
		<link rel="icon" type="image/png" href="/static/favicon/favicon.png" />
		<link rel="manifest" href="/static/site.webmanifest">

		<link rel="preload" href="/static/main.css" as="style" />
		<link rel="stylesheet" href="/static/main.css" />
		<script src="/static/main.js"></script>
		
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVFWK2DDQF"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){ dataLayer.push(arguments); }
			gtag('js', new Date());
			gtag('config', 'G-ZVFWK2DDQF');
		</script>

		

<link href="/static/prism.css" rel="stylesheet" />

	</head>
	<body>
		<div class="logo-graphic">
			<img draggable="false" src="/static/commonprefix_logo.jpg" alt="" />
			<img
				style="visibility: hidden"
				class="logo-graphic__clip"
				draggable="false"
				src="/static/commonprefix_logo.jpg"
				alt=""
			/>
		</div>

		<div class="outer-container">
			<div class="container">
				<div class="small-container">
					<header>
						<a href="/" class="header__company-name"
							><h2>Common <span>⎵</span> Prefix</h2>
						</a>
						<nav>
							<a href="/team.html">Team</a>
							<a href="/research.html">Research</a>
							
							<a href="/bridges.html">Bridges</a>
							<a href="/blog/">Blog</a>
							<a href="/careers.html" class="careers-link">Careers</a>
						</nav>
					</header>

					
<main class="blog-post">
	<h1>The Landscape of Front-running Prevention</h1>
	<h5 class="mono light blog-post__date">01/09/2025<br />
		<div class="blog-post__authors">
		
			<a href="/team#lioba">Lioba Heimbach</a>
		
		</div>
	</h5>
	<h5>Reading time: 6 minutes</h5>

	

	<section class="content">
		<p>Picture this: on a quiet Sunday morning, Alice is excited to swap a few ETH for a hot new token on a decentralized exchange. She submits her transaction and leans back, coffee in hand. Her request goes into the mempool, the public pool of unconfirmed transactions that anyone on the network can inspect. A predatory bot spots Alice’s pending order, submits its own buy transaction before hers, and then places a sell transaction immediately after hers, causing her swap to execute at a significantly worse price rate. This is referred to as <em>front‑running</em> in decentralized finance. Front‑running happens when someone has advance knowledge of your pending transaction and executes theirs first to profit from the predictable price impact.</p>

<p><img src="/static/blog/landscape-of-front-running-prevention/landscape_of_front_running_prevention.png" alt="Landscape Of Front-running Prevention" /></p>

<p>Peek into any mempool and you will see two main front‑running strategies at work: <em>sandwich attacks</em>, where a bot places orders before and after yours to skim the spread; and <em>generalized front‑running</em>, where it copies your pending transaction (for example, an arbitrage transaction) to capture the associated profit before you. Both tactics exploit the transparent pool of unconfirmed transactions and rely on advance knowledge of your intent. The sandwich technique squeezes your trade on both sides for profit, while generalized front‑running steals the profit your transaction was intended to secure.</p>

<h2 id="what-can-we-do-against-front-running">What can we do against front-running?</h2>

<p>Given the prevalence of front‑running on Ethereum, the mempool is often called a “dark forest” where bots prey on unconfirmed transactions. This environment has inspired a range of academic and industry proposals to address front‑running, and we will explore their respective strengths and weaknesses.</p>

<h3 id="trusted-third-party-ordering">Trusted-third party ordering</h3>

<p>Imagine Alice skips the public mempool and sends her swap directly to a single sequencer. That sequencer queues each transaction in the exact order received and executes them in turn. For Alice, this feels like breathing fresh air: her trade confirms quickly, with no additional fees or unpredictable delays. The catch is that she has handed full control over ordering to one operator, sacrificing decentralization and censorship resistance. If the sequencer chooses to delay, reorder, or block her transaction, Alice has no fallback option. To reduce this risk, some systems run the sequencer inside a trusted execution environment offering cryptographic proof of fair handling, but the core trade-off between efficiency and centralization remains.</p>

<h3 id="algorithmic-committee-ordering">Algorithmic committee ordering</h3>

<p>Consider a model where Alice sends her transaction to a committee rather than a single sequencer. This approach, referred to as <em>algorithmic committee ordering</em>, has the group of validators run a consensus protocol to agree on an ordering that approximates first-come, first-served, since network delays make agreement on exact FCFS between a distributed set of nodes impossible. By spreading sequencing responsibility across multiple nodes, it tolerates a subset of Byzantine actors and avoids a single point of failure, but it still concentrates influence among committee members and favors those with faster network connections. In some implementations, the nodes in the committee run inside a TEE, reducing how much Alice needs to trust the committee members.</p>

<h3 id="commit-and-reveal">Commit and reveal</h3>

<p>This approach, known as <em>commit and reveal</em>, or otherwise referred to as <em>encrypted mempools</em>, begins with Alice locking her swap into an encrypted envelope by publishing only the ciphertext. The network then orders these sealed commitments without knowing what’s inside. At the reveal stage, the decryption key becomes available and validators unlock each envelope to execute the underlying transaction in its reserved position. Commit and reveal protocols keep pending transactions completely hidden, giving Alice some of the strongest protection against front-running and reducing her reliance on any single actor. The trade-offs include two extra protocol phases that add latency and on-chain overhead, as well as the potential for higher transaction revert rates given the added uncertainty regarding the state they will execute on.</p>

<h3 id="mev-redistribution">MEV redistribution</h3>

<p>To turn front-runner profits into user gains, Alice can opt into MEV redistribution. Rather than just sending her swap to the public mempool, her transaction enters an auction where searchers submit bids for the right to front-run and/or back-run her transaction in a bundle. When the auction closes, Alice’s trade executes along with the winning bundle. Further, a share of the winning bid is paid directly to Alice, giving her a share of the upside that her transaction generated. In a healthy, competitive market without collusion, bids climb toward the true extractable value, ensuring Alice captures most of the upside. This model depends on a diverse ecosystem of searchers and robust auction mechanics to prevent collusion. At the same time, running the auction can add extra steps to the process, which may introduce delays for Alice’s trade.</p>

<h2 id="why-is-front-running-still-prevalent">Why is front-running still prevalent?</h2>

<p>Now these defenses all exist, yet Alice still gets sniped. After a quiet afternoon, she checks her wallet and discovers her swap was front-run once again. Why is this happening? Most protections require users to opt in; they only shield those who actively enable them. A handful of mechanisms could protect every user by default, but the majority of those implemented only help users who know to use them. For example, Flashbots has offered users a service to submit their transactions privately <sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup> for multiple years, but has done little to defend the traders most at risk. If Alice never learns about these shields, she never activates them and remains prey to mempool predators.</p>

<h2 id="where-do-we-go-from-here">Where do we go from here?</h2>

<p>In the short term, we must bring every Alice up to speed and build protections into the tools she already uses. Education campaigns, i.e., tutorials, blog posts and in-app tips <sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> <sup class="footnote-ref" id="fnref:3"><a href="#fn:3">3</a></sup> <sup class="footnote-ref" id="fnref:4"><a href="#fn:4">4</a></sup>, can make all users aware of front-running risks and defenses. Meanwhile, wallet and RPC providers should bake in default safeguards for every transaction. By submitting transactions privately, for example, every swap gets a layer of protection without requiring Alice to opt in.
In the long term, we need to move beyond today’s stopgap measures. Many of the solutions we’ve seen introduce unwanted centralization or impose efficiency costs. To deliver fairness, decentralization, and performance in one package, the community must continue researching new protocol designs. Only by pushing this frontier can we ensure that every Alice trades on a truly level playing field by default.</p>

<h3 id="references">References</h3>

<div class="footnotes">


<ol>
<li id="fn:1"><a href="https://protectrpc.flashbots.net/" target="_blank">https://protectrpc.flashbots.net/</a><br>
</li>

<li id="fn:2"><a href="https://www.quicknode.com/guides/ethereum-development/MEV/what-is-mev" target="_blank">https://www.quicknode.com/guides/ethereum-development/MEV/what-is-mev</a><br>
</li>

<li id="fn:3"><a href="https://www.blocknative.com/blog/mev-protection-sandwiching-frontrunning-bots" target="_blank">https://www.blocknative.com/blog/mev-protection-sandwiching-frontrunning-bots</a><br>
</li>

<li id="fn:4"><a href="https://metamask.io/news/introducing-smart-transactions" target="_blank">https://metamask.io/news/introducing-smart-transactions</a><br>
</li>
</ol>

</div>

	</section>

	<script
	  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
	  type="text/javascript">
	</script>
	<script src="/static/prism.js"></script>
</main>


					<footer>
						<div class="socials">
							<h3>Get in touch</h3>
							<a
								class="mbtn"
								href="mailto:hello@commonprefix.com"
							>
								<span class="un">hello@commonprefix.com</span>
							</a>
							<a
								class="mbtn"
								href="https://twitter.com/CommonPrefix"
							>
								<span class="un">@commonprefix</span>
							</a>
							<a
								class="mbtn"
								href="https://github.com/commonprefix"
							>
								<span class="un">GitHub</span>
							</a>
						</div>
						<div class="socials">
							<a
								class="mbtn"
								href="https://pod.network"
								target="_blank"
								rel="noopener noreferrer"
							>
								<span class="un">pod.network</span>
							</a>
							<a
								class="mbtn"
								href="https://chaingrowth.xyz"
								target="_blank"
								rel="noopener noreferrer"
							>
								<span class="un">chaingrowth.xyz</span>
							</a>
						</div>
						<div class="footer__easter-egg">
							<img
								width="220px"
								style="opacity: 0.5"
								src="/static/footer_eq.svg"
								draggable="false"
								alt=""
							/>
							<img
								width="220px"
								style="mix-blend-mode: multiply"
								src="/static/footer_blockchain.png"
								draggable="false"
								alt=""
							/>
							<p>
								Rumpetur paritas cum sequens probatio operis
								invenietur et ramus maior fiet.
							</p>
						</div>
					</footer>
				</div>
			</div>
		</div>

		<script>
			;(function () {
				
				document.querySelector('.footer__easter-egg').children[
					Math.floor(Math.random() * 3)
				].style.visibility = 'visible'

				
				window.requestAnimationFrame =
					window.requestAnimationFrame ||
					function (C) {
						return setTimeout(function () {
							C(+new Date())
						}, 30)
					}

				function isTouchDevice() {
					var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ')
					var mq = function (query) {
						return window.matchMedia(query).matches
					}

					if (
						'ontouchstart' in window ||
						(window.DocumentTouch &&
							document instanceof DocumentTouch)
					) {
						return true
					}

					var query = [
						'(',
						prefixes.join('touch-enabled),('),
						'heartz',
						')',
					].join('')
					return mq(query)
				}

				var touchDevice = isTouchDevice()
				if (touchDevice) {
					document.body.classList.add('touchdevice')
				}

				var graphic = document.querySelector('.logo-graphic')
				var clip = document.querySelector('.logo-graphic__clip')

				if (!touchDevice) {
					var v = `radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, transparent 120px)`
					clip.style = `-webkit-mask-image: ${v}; mask-image: ${v};`

					function reveal(e) {
						var pos = graphic.getBoundingClientRect()
						var x = e.clientX - pos.left - 150
						var y = e.clientY - pos.top + 150

						var v = `radial-gradient(circle at ${x}px ${y}px, black 0px, black 60px, transparent 120px)`
						clip.style = `-webkit-mask-image: ${v}; mask-image: ${v};`
					}

					window.addEventListener('mousemove', function (e) {
						requestAnimationFrame(() => reveal(e))
					})
				}
			})()
		</script>
	</body>
</html>
