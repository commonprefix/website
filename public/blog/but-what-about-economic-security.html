
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Common Prefix — But, what about Economic Security?</title>
		<meta name="description" content="A technical examination of economic security in blockchain systems and the design trade-offs involved in strengthening it." />

		<meta property="og:title" content="Common Prefix — But, what about Economic Security?">
		<meta property="og:description" content="A technical examination of economic security in blockchain systems and the design trade-offs involved in strengthening it.">
		<meta property="og:url" content="https://commonprefix.com/">
		<meta property="og:image" content="https://commonprefix.com/static/meta.png">

		<meta name="twitter:title" content="Common Prefix — But, what about Economic Security?">
		<meta name="twitter:description" content="A technical examination of economic security in blockchain systems and the design trade-offs involved in strengthening it.">
		<meta property="twitter:url" content="https://commonprefix.com/">
		<meta name="twitter:image" content="https://commonprefix.com/static/meta.png">
		<meta name="twitter:card" content="summary_large_image">
		<meta property="twitter:domain" content="commonprefix.com">

		<link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png">
		<link rel="icon" type="image/png" href="/static/favicon/favicon.png" />
		<link rel="manifest" href="/static/site.webmanifest">

		<link rel="preload" href="/static/main.css" as="style" />
		<link rel="stylesheet" href="/static/main.css" />
		<script src="/static/main.js"></script>
		
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVFWK2DDQF"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){ dataLayer.push(arguments); }
			gtag('js', new Date());
			gtag('config', 'G-ZVFWK2DDQF');
		</script>

		

<link href="/static/prism.css" rel="stylesheet" />

	</head>
	<body>
		<div class="logo-graphic">
			<img draggable="false" src="/static/commonprefix_logo.jpg" alt="" />
			<img
				style="visibility: hidden"
				class="logo-graphic__clip"
				draggable="false"
				src="/static/commonprefix_logo.jpg"
				alt=""
			/>
		</div>

		<div class="outer-container">
			<div class="container">
				<div class="small-container">
					<header>
						<a href="/" class="header__company-name">
							<img
								src="/static/cp-text-logo.svg"
								alt="Common Prefix"
								class="header__logo"
							/>
						</a>
						<nav>
							<a href="/team.html">Team</a>
							<a href="/research.html">Research</a>
							
							<a href="/bridges.html">Bridges</a>
							<a href="/blog/">Blog</a>
							<a href="/podcast.html">Podcast</a>
							<a href="/careers.html" class="careers-link">Careers</a>
						</nav>
					</header>

					
<main class="blog-post">
	<h1>But, what about Economic Security?</h1>
	<h5 class="mono light blog-post__date">27/01/2026<br />
		<div class="blog-post__authors">
		
			<a href="/team#dimitris">Dr. Dimitris Karakostas</a>
		
		</div>
	</h5>
	<h5>Reading time: 9 minutes</h5>

	

	<section class="content">
		<h2 id="summary">Summary:</h2>

<ul>
<li><em>Blockchain systems are secured by resources, such as stake or computational power. If the resource’s price goes down, the cost of buying enough resources to attack the system also goes down.</em></li>
<li><em>When an attack’s profit is higher than its cost, then the system becomes (economically) insecure.</em></li>
<li><em>To prevent economic attacks, the system can use alternative resources, whose price does not fluctuate much. These alternative resources can either back special-purpose modules, such as checkpointing, or be used interchangeably with the system’s native resource.</em></li>
</ul>

<p>Economic security of blockchain systems is often heralded as the utmost guarantee to strive for. The essence of it is encapsulated by the question: “is the cost of attacking a blockchain system lower than the potential attack profit?”</p>

<p>Answering this question in practice is particularly cumbersome, which is possibly why it is rarely achieved - or discussed - in practice. The main issue is that both the cost and the profit of an attack are often hard to estimate. To make matters worse, the lack of historical attacks is regularly treated as proof of a system’s economic security; “if an attack was profitable, why hasn’t it happened yet?” ask the proponents of this argument. With the introduction of blockchain systems dedicated to particular use cases, such as bridges, and the observation of more sophisticated attacks, the need for proper guarantees, as opposed to heuristics and wishful thinking, is more pressing than ever.</p>

<p>In the cryptographic literature, the economic security question has been most commonly explored in the context of “bootstrapping” newly deployed systems. In this case, the motivation is to protect a system in its infancy, when it has not acquired yet enough capital to secure it, while also enabling it to grow its financial activity. Nonetheless, the question is relevant in all cases when the capital used to secure a blockchain system, i.e., the cost of preventing an attack, is significantly lower than the economic activity hosted on the same system, i.e., the potential profit of an attack.</p>

<p>In this blog post, we explore the most common and well-studied options for enhancing a system’s economic security.</p>

<h1 id="different-assets-for-different-jobs">Different assets for different jobs</h1>

<p>The first approach is to use different resources, such as staking assets, for securing different parts of the system. For example, the parties that control resource A would run the block producing protocol, whereas the parties that control resource B could run a finality gadget for achieving optimistically faster finality (such as GRANDPA<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>), while resource C would back a committee that enforces slashing, and so on.</p>

<p>In this case, the security of each of the system’s modules is independently backed by a different resource. The main benefit of this approach is that, when the modules are independent, compromising one type of resource could be contained within only the given module. In the above example, if the majority of resource B is adversarially controlled, then the finality gadget would be compromised, so the system would slow down as transactions would be finalized on the (slower) base layer.</p>

<p>However, if the composition of modules is tighter, compromising one could lead to adverse effects in another. Again looking at the above example, if the majority of resource C is maliciously controlled, then the adversary could potentially slash honest parties. In that scenario, honest control over resource A would be reduced, potentially cascading to a compromise of the block production mechanism.</p>

<p>One instance where this approach is used in practice is Babylon. Specifically, Babylon uses both Bitcoin and BABY staking. BABY token holders produce blocks in the Babylon Genesis chain by running a CometBFT protocol instance. Bitcoin stakers act as <a href="https://docs.babylonlabs.io/guides/architecture/babylon_genesis_modules/finality/" target="_blank">finality provider</a>, who run a voting protocol that finalizes blocks. Although these two staking processes are seemingly independent, Bitcoin staking is prioritized over BABY staking; for instance, if more than one third of staked Bitcoin fails to participate, then the finalization process - and the whole system - stalls.</p>

<h1 id="checkpointing">Checkpointing</h1>

<p>The second approach is a special case of the resource-based job allocation of the first approach. Here the whole system is backed by a single resource, except a single module that periodically checkpoints the system’s state. Checkpoints are unambiguous commitments of the system’s state which cannot be rolled back, preventing chain reorganization or long-range attacks. As long as the checkpointing protocol is secure, checkpoints both are produced on time and are not conflicting.</p>

<p>Checkpointing is a well-known practice that has been extensively studied and used in practice, most often discussed in the context of bootstrapping new systems <sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> <sup class="footnote-ref" id="fnref:3"><a href="#fn:3">3</a></sup> <sup class="footnote-ref" id="fnref:4"><a href="#fn:4">4</a></sup>. There are various ways to implement checkpointing and various resources can be used to support the checkpointing protocol.</p>

<p>Most commonly, checkpointing is run by a committee of parties. These parties collectively sign each checkpoint and, as long as the majority of committee members are honest, checkpoints are correctly issued, meaning both that they are produced on time and that no two checkpoints correspond to conflicting states. The committee members are selected in a permissioned manner, e.g., by centrally choosing a set of designated parties or electing them based on their control of some alternative resource, like stake.</p>

<p>An alternative approach is using an external blockchain to record and organize checkpoints. In this case, the ledger’s state is periodically committed within transactions in the checkpointing blockchain. If the checkpointing blockchain is secure, meaning that it offers safety and liveness guarantees, then the checkpoints are published in an absolute and persistent order. In practice, this approach is also <a href="https://docs.babylonlabs.io/guides/architecture/babylon_genesis_modules/checkpointing/" target="_blank">used in Babylon</a>, where the state of the Babylon Genesis chain is periodically published on the Bitcoin blockchain.</p>

<p>The main concern regarding checkpointing is that the system’s security relies solely on the security of the checkpointing module. Specifically, the final choice of the canonical state of the system is made via the issued checkpoints. If the checkpointing module is compromised, e.g., if the checkpointing committee becomes malicious or the checkpointing blockchain is vulnerable, then the system’s security guarantees break down.</p>

<h1 id="synthetic-stake">Synthetic stake</h1>

<p>In both previous approaches the system’s security is eventually dependent on control over a single resource. In the first approach, even if alternative resources are used for securing different parts of the system, the core module is controlled by a single type of resource. Similarly, under checkpointing the final decision regarding the system’s state is made via the checkpoints, which are again controlled by a single resource.</p>

<p>Ideally, we would like to enable the fusion of multiple interchangeable resources, where security is guaranteed if the cumulative power across all resources is honest. Here, different resources are pooled together in a fungible manner to create a “synthetic” (or “virtual”) resource and security is guaranteed as long as the adversary controls a small percentage of the synthetic resources.</p>

<p>Although this approach is particularly appealing, due to its powerful assurances and decentralized nature, it is also the hardest to implement and analyze. Various protocols have been proposed towards this direction, mostly combining computational resources (Proof-of-Work) with digital assets (Proof-of-Stake). For example, in practice, Zano uses a hybrid consensus protocol that combines PoW mining and PoS staking. However, most academic protocols either lack formal guarantees <sup class="footnote-ref" id="fnref:5"><a href="#fn:5">5</a></sup> <sup class="footnote-ref" id="fnref:7"><a href="#fn:7">6</a></sup> or end up prioritizing one over the other <sup class="footnote-ref" id="fnref:6"><a href="#fn:6">7</a></sup>. Interestingly, a recent promising result presented a concrete protocol that tolerates any adversarial minority over the combined resources <sup class="footnote-ref" id="fnref:8"><a href="#fn:8">8</a></sup>.</p>

<p>The core complication with synthetic stake is that fusing heterogeneous assets in a fungible manner fundamentally requires a common denomination between all assets. In other words, the system should know the exchange rate of each asset with respect to a common unit of measure. For example, in the case of stake, the common unit of measure is typically USD and the exchange rate is the market price of each token.</p>

<p>The problem is that market prices are not immediately available to a blockchain system, but instead are accessible via oracles. Therefore, the system’s security becomes highly dependent on the oracle’s implementation and trust assumptions. Such oracles are implemented either via a trusted third party, a distributed computing system, or on-chain marketplaces. Each of these options present a tradeoff between high accuracy and centralization.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Increasing economic security of blockchain systems is a pressing problem, particularly when the capital that secures the system is much less than the financial activity conducted on it.</p>

<p>Fortunately various solutions exist, each offering different performance and trust guarantees. First, using different resources for each of the system’s modules can diversify the security capital, as long as these modules are independent and one’s failure is not contagious to the rest of the system. Second, implementing a checkpointing service, which is backed by an alternative resource, is a well-studied and efficient method, albeit the security guarantees essentially move from one resource to another. Third, fusing multiple resources to create synthetic stake is a very promising option for increasing economic security in a decentralized manner. Nonetheless, properly designing and implementing an on-chain price oracle for each resource is a delicate process that, if done incorrectly, may introduce unforeseen hazards or centralization tendencies.</p>

<p>Regardless of which option one chooses though, a designer’s first step should always be to understand their own system’s particularities. Once they define how their system’s modules cooperate, which trust and centralization compromises they can tolerate, and what level of performance they strive for, choosing an appropriate solution should become straightforward.</p>

<h3 id="references">References</h3>

<div class="footnotes">


<ol>
<li id="fn:1">Stewart, Alistair, and Eleftherios Kokoris-Kogia. &ldquo;Grandpa: a byzantine finality gadget.&rdquo; arXiv preprint arXiv:2007.01560 (2020); <a href="https://arxiv.org/pdf/2007.01560" target="_blank">arXiv 2007.01560</a></li>

<li id="fn:2">Rana, Ranvir, et al. &ldquo;Optimal bootstrapping of pow blockchains.&rdquo; Proceedings of the Twenty-Third International Symposium on Theory, Algorithmic Foundations, and Protocol Design for Mobile Networks and Mobile Computing. 2022; <a href="https://arxiv.org/pdf/2208.10618" target="_blank">arxiv 2208.10618</a></li>

<li id="fn:3">Karakostas, Dimitris, and Aggelos Kiayias. &ldquo;Securing proof-of-work ledgers via checkpointing.&rdquo; 2021 IEEE International Conference on Blockchain and Cryptocurrency (ICBC). IEEE, 2021; <a href="https://eprint.iacr.org/2020/173.pdf" target="_blank">eprint 2020 / 173</a></li>

<li id="fn:4">Dinsdale-Young, Thomas, et al. &ldquo;Afgjort: A partially synchronous finality layer for blockchains.&rdquo; International Conference on Security and Cryptography for Networks. Cham: Springer International Publishing, 2020; <a href="https://eprint.iacr.org/2019/504.pdf" target="_blank">eprint 2019 / 504</a></li>

<li id="fn:5">Bentov, Iddo, et al. &ldquo;Proof of activity: Extending bitcoin&rsquo;s proof of work via proof of stake [Extended abstract].&rdquo; ACM SIGMETRICS Performance Evaluation Review 42.3 (2014): 34-37; <a href="https://dl.acm.org/doi/epdf/10.1145/2695533.2695545" target="_blank">DOI 10.1145 / 2695533.2695545</a></li>

<li id="fn:7">Duong, Tuyet, et al. &ldquo;Twinscoin: A cryptocurrency via proof-of-work and proof-of-stake.&rdquo; Proceedings of the 2nd ACM Workshop on Blockchains, Cryptocurrencies, and Contracts. 2018; <a href="https://dl.acm.org/doi/pdf/10.1145/3205230.3205233" target="_blank">DOI 10.1145 / 3205230.3205233</a></li>

<li id="fn:6">Duong, Tuyet, et al. &ldquo;2-hop blockchain: combining proof-of-work and proof-of-stake securely.&rdquo; European Symposium on Research in Computer Security. Cham: Springer International Publishing, 2020; <a href="https://eprint.iacr.org/2016/716.pdf" target="_blank">eprint 2016 / 716</a></li>

<li id="fn:8">Fitzi, Matthias, et al. &ldquo;Minotaur: Multi-resource blockchain consensus.&rdquo; Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security. 2022; <a href="https://dl.acm.org/doi/epdf/10.1145/3548606.3559356" target="_blank">DOI 10.1145 / 3548606.3559356</a></li>
</ol>

</div>

	</section>

	<script
	  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
	  type="text/javascript">
	</script>
	<script src="/static/prism.js"></script>
</main>


					<footer>
						<div class="socials">
							<h3>Get in touch</h3>
							<a
								class="mbtn"
								href="mailto:hello@commonprefix.com"
							>
								<span class="un">hello@commonprefix.com</span>
							</a>
							<a
								class="mbtn"
								href="https://twitter.com/CommonPrefix"
							>
								<span class="un">@commonprefix</span>
							</a>
						</div>
						<div class="socials">
							<br>
							<a
								class="mbtn"
								href="https://github.com/commonprefix"
							>
								<span class="un">GitHub</span>
							</a>							
							<a
								class="mbtn"
								href="https://chaingrowth.xyz"
								target="_blank"
								rel="noopener noreferrer"
							>
								<span class="un">chaingrowth.xyz</span>
							</a>
						</div>
						<div class="footer__easter-egg">
							<img
								width="220px"
								style="opacity: 0.5"
								src="/static/footer_eq.svg"
								draggable="false"
								alt=""
							/>
							<img
								width="220px"
								style="mix-blend-mode: multiply"
								src="/static/footer_blockchain.png"
								draggable="false"
								alt=""
							/>
							<p>
								Rumpetur paritas cum sequens probatio operis
								invenietur et ramus maior fiet.
							</p>
						</div>
					</footer>
				</div>
			</div>
		</div>

		<script>
			;(function () {
				
				document.querySelector('.footer__easter-egg').children[
					Math.floor(Math.random() * 3)
				].style.visibility = 'visible'

				
				window.requestAnimationFrame =
					window.requestAnimationFrame ||
					function (C) {
						return setTimeout(function () {
							C(+new Date())
						}, 30)
					}

				function isTouchDevice() {
					var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ')
					var mq = function (query) {
						return window.matchMedia(query).matches
					}

					if (
						'ontouchstart' in window ||
						(window.DocumentTouch &&
							document instanceof DocumentTouch)
					) {
						return true
					}

					var query = [
						'(',
						prefixes.join('touch-enabled),('),
						'heartz',
						')',
					].join('')
					return mq(query)
				}

				var touchDevice = isTouchDevice()
				if (touchDevice) {
					document.body.classList.add('touchdevice')
				}

				var graphic = document.querySelector('.logo-graphic')
				var clip = document.querySelector('.logo-graphic__clip')

				if (!touchDevice) {
					var v = `radial-gradient(circle at 0px 0px, transparent 0px, transparent 60px, transparent 120px)`
					clip.style = `-webkit-mask-image: ${v}; mask-image: ${v};`

					function reveal(e) {
						var pos = graphic.getBoundingClientRect()
						var x = e.clientX - pos.left - 150
						var y = e.clientY - pos.top + 150

						var v = `radial-gradient(circle at ${x}px ${y}px, black 0px, black 60px, transparent 120px)`
						clip.style = `-webkit-mask-image: ${v}; mask-image: ${v};`
					}

					window.addEventListener('mousemove', function (e) {
						requestAnimationFrame(() => reveal(e))
					})
				}
			})()
		</script>
	</body>
</html>
